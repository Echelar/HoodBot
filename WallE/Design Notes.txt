WallE is designed to implement as much of the MediaWiki API as is feasible in a .NET framework. It is NOT meant to be a high-level bot framework—it's more of a framework to a framework. The overall goal was to implement the API in a programmer-friendly manner, while still working very much like the API itself does.

== Goals ==
* Implement the API in C#, but staying close to the API design itself.
* Reduce or eliminate housekeeping such as token management, and retry handling.
* Be flexible and expandable. As much as possible, provide a framework to allow expansion, or adding of user-created modules/functions.
* Provide interfaces and factories for major components in favour of single concrete implementations. In theory, someone should be able to closely reproduce the functionality of the framework by designing a direct-to-database layer, a screen-scraping layer (index.php), or even a hybrid read-only-API/writable-index.php layer. (Note: this may need additional work. I think I've done a good job with what needs interfaces, but only one or two things use factory methods and similar techniques.)
* Handle API bugs and quirks as much as possible, where known.
* Be version-agnostic, without throwing errors or warnings unless the wiki itself does, using MW 1.16 as a cutoff for full support. (This was the oldest version I could find still in use when I first started the project, and since the API really started to mature around then, it made sense to start there.)

== Usage Notes ==
* Currently, this code is intended strictly for designers, not for public consumption. As such, it uses C# 7 release-candidate code, as well as the following NuGet packages, which you will need to install in order to compile:
** WallE: Newtonsoft.Json, StyleCop.Analyzers, System.ValueTuple
** WallETests: StyleCop.Analyzers
* Tests are geared towards integration testing, not unit testing. In order to get them to work, you should copy WikiListExample.txt to WikiList.txt, remove the first line and fill the rest with name/password information for TESTING wikis. Do NOT use this on public wikis! The WikiList.txt file should automatically be ignored, but this should be double-checked before pushing to GitHub. (Note: the entire testing setup is insanely primitive and the design will likely be changed at some point, including conversion to Json or some other format.)
* Tokens are implemented internally in order to be correct across versions. While accessible for special uses, there should be no need for the user to worry about managing them at all.
* Where parameters are required, constructors force them to be specified. This done for most cases, but some were far too complex for this to be a realistic approach. In those cases, it's trusted that the caller will call them correctly (and the wiki will tell them if they goofed).
* Parameters in result types are generally settable due to the friend-like nature of the design, as well as allowing easy expansion/inheritance. Making them protected and/or internal or creating designers for every last one of them didn't seem like good design choices. The exceptions are the various collections and dictionaries, which are all read-only in order to prevent accidental addition. This design may change if anyone has a good solution or, flipping it around, read-only collections and dictionaries may be converted to writable ones if desired.
* Boolean values for inputs are generally implemented as distinct booleans rather than bit flags. This is due to the fact that enumerations cannot be inherited, and some inputs are shared by several routines. Result types are a bit more variable on this front due to the fact that very few result types ever inherit from one another, and that there are often a very large number of booleans to handle. I may reconsider this strategy, and would love to get input from people as to which way is preferable (or if I should use workarounds like classes that simulate enums with constants).
* Enumerated values are implemented as such for inputs, but usually not for return values. This is a bit of a tradeoff between ease of use and flexible design. I went for the middle ground, since input types not included in an enumeration simply mean features you can't use on later wiki versions, while unhandled output types could generate errors or cause unexpected behaviour. In theory, I could provide both ease of use and expandibility by providing both text values *and* enumerated values, but this seemed like overkill.
* Return collections are normally straight-up read-only lists or dictionaries, or if other properties are returned, the result object is collection itself (as opposed to the collection being returned as a property of the result object). This was not a consistent rule during initial design, however. Please feel free to point out any cases where it would make sense to do this, but I haven't.

=== Naming ===
In order to reduce naming conflicts within the project and with higher-tier clients, all API-related classes use names that are unlikely to be used outside the project, while still being meaningful (e.g., PageItem instead of Page). Specifically, prototype object names follow these rules, in order:
# Any name which would become silly as a result of these rules is renamed more logically on a case-by-case basis (e.g., PageItem.Info is of type PageInfo, not InfoInfo or, worse, PageItemInfoInfo).
# As much as possible, all elements start with the same name as the relevant API feature, parameter name, or result name. Abbreviations have been expanded in most cases and lower-case names are camel-cased per C# standard (e.g., "rcid" becomes "RecentChangesId").
# Input types all end in "Input" (e.g., BlockInput).
# Collection items start with the full name of the collection and end in "Item" (e.g., MagicWordsItem).
# Top-level result classes end in "Result" (e.g., EditResult).
# Substructures end in "Info" (e.g., ChangeableGroupsInfo).

== Not Implemented ==
* The goal was not to reproduce the API to exacting detail. In some cases, minor details were changed for ease of use, and a couple of the clunkier input/result mechanisms have been redesigned to hopefully be more usable/intuitive. While probably 98-99% of the API is implemented by this framework, some things simply made no sense to implement given the nature of the framework, and there are a few arcane things where the effort to reproduce a feature that will probably never be used was simply not justifiable. If these things actually are needed for some reason, I'm happy to look into them, however. These will be documented (in progress) at a high level below and more granularly in the code itself.
* With one or two exceptions, extensions are not generally considered in the design, even those bundled with MediaWiki or in use on MediaWiki sites. It is largely left up to the client to expand the framework as necessary if required for whatever wikis they will be using.
* Upload by URL. It was excessively complex, and probably not a huge need for bot designers. All other forms of uploading work as expected.
* Clientlogin. As of this writing, this is a new login process. Documentation is relatively sparse. I'm waiting to see how this stabilizes before approaching it. For now, the standard login module simply swallows the warning that MW generates (and even that can be eliminated if you use the bot passwords feature).
* OAuth. Even though MediaWiki uses this, no other wiki I know of does, and it's an extension to boot. My initial impression is that the whole AuthManager design is some kind of cryptic programmers wet dream, integrated into MediaWiki in the absence of any feedback from actual consumers of the API. Much like the scientists in Jurassic Park, they "were so preoccupied with whether or not they could that they didn't stop to think if they should". I have doubts as to whether OAuth itself will ever be used outside of MediaWiki projects in the long run, so it will likely remain unimplemented.
* Stashedit. This is geared towards (internal-only?) AJAX usage, not this type of bot.
* Tokens. As noted above, these are implemented internally. The API Token module is not accessible as a distinct entity, but all tokens can be retrieved through the token manager. In addition, some token-fetching functions, like the Block/Unblock modules, remain unimplemented for the simple reason that they're identical to the edit token.

=== Other ===
* There is limited input checking, mostly taking the form of null-checking and constructor-based enforcement of supplying required parameters. This is by design. What is considered an error today may not be tomorrow. For the most part, WallE lets the wiki decide what constitutes an error, rather than deciding on its own. This means a bit more communication with the server, but has the benefit of not unduly restricting the client if wiki functionality is changed.
* Similarly, there is little error-handling. This is both for debugging purposes and because the vast majority of errors will be wiki-generated errors that WallE dutifully throws and lets the client figure out how to handle. Exceptions apart from these should be noted so that they can be fixed, worked around, or caught.
* This project has been stop-and-go for the last couple of years. Modules are currently therefore implemented to whatever MW version was current at the time I designed them. Only later modules document which version that is (with the MWVERSION comment tag).
* Inline XML documentation is only present for public classes that do not directly reflect the API. Because inputs and results so closely match the API, these will not be documented at all except to note significant deviations from the API.
* Significant breaks from the API or unimplemented features are starting to be documented in inline comments using an IMPNOTE tag. These will eventually be applied universally.
* I'm chronically ill, so I can't promise to implement the latest and greatest features at every release. Most likely, I will harmonize everything to v1.30 or thereabouts, and any requirements after that will be on an on-demand basis (or, more likely, left to WallE v2, which will set a baseline of 1.30 and strip out old code that is no longer required).
* An asynchronous version of this was also developed during the design phase using .NET 4.5's async features. It proved too difficult to debug and maintain, and was mostly backed out (a couple of IMediaWikiClients were kept around, since they don't interfere with anything, but that's it). Once the overall design is stable, I'm willing to entertain re-adding asynchrony or developing a parallel library, if anyone feels the need.

== Last But Not Least ==
* If you would like to contribute to this project, please let me know. Probably the easiest way to get in touch is to leave a message on my talk page at the main MediaWiki site, or use its e-mail user function.
* For most of my life, I was a database designer, and programming was either in support of that (e.g., Access), or done as a hobby...or perhaps "obsession" would be a better word. I'd like to think that I'm a fairly good programmer, and this project has significantly increased my skills, but I'm still no Jon Skeet. Even if you don't want to get directly involved in the coding, if you see a design that could be improved, please feel free to mention it to me or provide a link where I can read up on whatever pattern/design you have in mind.

-- RobinHood70